#!/usr/bin/env bash
set -euo pipefail

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
default_repo_dir="$(cd "${script_dir}/.." && pwd)"

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  cat <<'EOF'
Usage: updatePrintFleetService [options]

Options:
  --repo-dir=PATH        Repo directory (default: repo root)
  --service-user=USER    Repo owner user (default: printfleet)
  --service-name=NAME    systemd service name (default: printfleet)
  --no-stash             Do not stash local changes before pulling
  --skip-clean-pyc       Do not remove __pycache__/*.pyc before pulling
  --non-interactive      Use defaults for missing values (no prompts)
EOF
  exit 0
fi

if [[ "$(id -u)" -ne 0 ]]; then
  echo "ERROR: Run as root (sudo -i)."
  exit 1
fi

if ! command -v systemctl >/dev/null 2>&1; then
  echo "ERROR: systemctl not found. This container must use systemd."
  exit 1
fi

REPO_DIR=""
SERVICE_USER=""
SERVICE_NAME=""
NON_INTERACTIVE=0
AUTO_STASH=1
AUTO_CLEAN_PYC=1
REQ_FILE=""

for arg in "$@"; do
  case "$arg" in
    --repo-dir=*)
      REPO_DIR="${arg#*=}"
      ;;
    --service-user=*)
      SERVICE_USER="${arg#*=}"
      ;;
    --service-name=*)
      SERVICE_NAME="${arg#*=}"
      ;;
    --no-stash)
      AUTO_STASH=0
      ;;
    --skip-clean-pyc)
      AUTO_CLEAN_PYC=0
      ;;
    --non-interactive)
      NON_INTERACTIVE=1
      ;;
    *)
      echo "Unknown option: $arg"
      exit 1
      ;;
  esac
done

prompt() {
  local label="$1"
  local default="$2"
  local value=""
  if [[ "$NON_INTERACTIVE" -eq 1 ]]; then
    printf '%s' "$default"
    return
  fi
  read -r -p "${label} [${default}]: " value
  if [[ -z "$value" ]]; then
    value="$default"
  fi
  printf '%s' "$value"
}

REPO_DIR="${REPO_DIR:-$(prompt "Repo directory" "$default_repo_dir")}"
SERVICE_USER="${SERVICE_USER:-$(prompt "Service user" "printfleet")}"
SERVICE_NAME="${SERVICE_NAME:-$(prompt "Service name" "printfleet")}"

REPO_DIR="$(cd "$REPO_DIR" && pwd)"

if [[ ! -d "$REPO_DIR/.git" ]]; then
  echo "ERROR: Git repo not found at ${REPO_DIR}"
  exit 1
fi

if ! systemctl list-unit-files --type=service --no-legend | awk '{print $1}' | grep -Fxq "${SERVICE_NAME}.service"; then
  echo "ERROR: Service not found: ${SERVICE_NAME}"
  exit 1
fi

SERVICE_STOPPED=0
STASHED_REF=""

cleanup() {
  local status=$?
  if [[ $status -ne 0 && $SERVICE_STOPPED -eq 1 ]]; then
    echo "Update failed. Starting service again."
    systemctl start "$SERVICE_NAME" || true
  fi
}

trap cleanup EXIT

echo "Stopping service: ${SERVICE_NAME}"
systemctl stop "$SERVICE_NAME"
SERVICE_STOPPED=1

clean_pycache() {
  find "$REPO_DIR" -type d -name '__pycache__' -prune -exec rm -rf {} + 2>/dev/null || true
  find "$REPO_DIR" -type f -name '*.pyc' -delete 2>/dev/null || true
}

run_as_service_user() {
  if id -u "$SERVICE_USER" >/dev/null 2>&1; then
    runuser -u "$SERVICE_USER" -- "$@"
  else
    "$@"
  fi
}

git_cmd() {
  if id -u "$SERVICE_USER" >/dev/null 2>&1; then
    runuser -u "$SERVICE_USER" -- git -C "$REPO_DIR" "$@"
  else
    git -C "$REPO_DIR" "$@"
  fi
}

is_dirty() {
  [[ -n "$(git_cmd status --porcelain)" ]]
}

stash_changes() {
  local message="$1"
  git_cmd stash push -u -m "$message" >/dev/null
  STASHED_REF="$(git_cmd stash list -1 --format=%gd)"
}

apply_stash() {
  local ref="$1"
  if [[ -z "$ref" ]]; then
    return 0
  fi
  git_cmd stash pop "$ref"
}

find_requirements() {
  if [[ -f "$REPO_DIR/requirements.txt" ]]; then
    REQ_FILE="$REPO_DIR/requirements.txt"
    return
  fi
  if [[ -f "$REPO_DIR/src/requirements.txt" ]]; then
    REQ_FILE="$REPO_DIR/src/requirements.txt"
  fi
}

install_requirements() {
  local py_bin="$REPO_DIR/.venv/bin/python"
  find_requirements

  if [[ -x "$py_bin" && -n "$REQ_FILE" ]]; then
    echo "Installing Python dependencies..."
    if ! run_as_service_user "$py_bin" -m pip install -r "$REQ_FILE"; then
      echo "WARNING: pip install failed. The service may start without new deps."
    fi
  else
    echo "WARNING: Python venv or requirements.txt not found. Skipping pip install."
  fi
}

echo "Updating repo..."
if id -u "$SERVICE_USER" >/dev/null 2>&1; then
  chown -R "${SERVICE_USER}:${SERVICE_USER}" "$REPO_DIR"
fi
if [[ "$AUTO_CLEAN_PYC" -eq 1 ]]; then
  echo "Removing Python cache files..."
  clean_pycache
fi

if is_dirty; then
  if [[ "$AUTO_STASH" -eq 0 ]]; then
    echo "ERROR: Local changes found. Commit or stash them, or run without --no-stash."
    exit 1
  fi

  if [[ "$NON_INTERACTIVE" -eq 1 ]]; then
    echo "Local changes found. Stashing changes..."
    stash_changes "auto-update-$(date +%Y%m%d-%H%M%S)"
  else
    read -r -p "Local changes found. Stash, update, and re-apply? (y/n) [y]: " confirm
    confirm="${confirm:-y}"
    if [[ "${confirm,,}" != "y" ]]; then
      echo "Aborted by user."
      exit 1
    fi
    stash_changes "auto-update-$(date +%Y%m%d-%H%M%S)"
  fi
fi

if ! id -u "$SERVICE_USER" >/dev/null 2>&1; then
  echo "WARNING: User ${SERVICE_USER} not found. Running git pull as root."
fi
git_cmd pull

if [[ -n "$STASHED_REF" ]]; then
  echo "Re-applying local changes..."
  if ! apply_stash "$STASHED_REF"; then
    echo "WARNING: Stash apply failed. Resolve conflicts and run:"
    echo "  git -C \"$REPO_DIR\" status"
    exit 1
  fi
fi

install_requirements

echo "Starting service: ${SERVICE_NAME}"
systemctl start "$SERVICE_NAME"
SERVICE_STOPPED=0
systemctl status "$SERVICE_NAME" --no-pager
